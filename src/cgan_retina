from pyexpat import model
from gan import CGAN
from mapper import RetinalImages
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.datasets import fashion_mnist
import tensorflow as tf
import numpy as np
from keras.utils.vis_utils import plot_model
from matplotlib import pyplot

train = RetinalImages.retinal_data
img_shape = (train.image_shape[0], train.image_shape[1], train.image_shape[2])

print (train.image_shape)
D = CGAN.discriminator(inputShape=img_shape)#train.image_shape)
G = CGAN.generator(res=0.01,inputShape=img_shape)#train.image_shape)
GAN = CGAN.gan(G, D)
print (G.summary())

# def train_disc(model: CGAN.discriminator, data, iter=20, n_batch=32):
#     for i in range(iter):
#         xreal, yreal = CGAN.gen_real(data, int(n_batch/2))
#         _, D_real = model.train_on_batch(xreal, yreal)
#         xfake, yfake = CGAN.gen_synthetic(int(n_batch/2), img_shape=train.image_shape)
#         _, D_noise = model.train_on_batch(xfake, yfake)
#         print('>%d real=%.0f%% fake=%.0f%%' % (i+1, D_real*100, D_noise*100))

# evaluate the discriminator, plot generated images, save generator model
def evaluate(epoch, g, d, data, latent=100, n_samples=30):
    xreal, yreal = CGAN.gen_real(data, 30)
    # _, D_real = model.train_on_batch(xreal, yreal)
    _, acc_real = d.evaluate(xreal, yreal, verbose=0)
    xfake, yfake = CGAN.gen_synthetic(CGAN, g, n_samples)
    # _, D_noise = model.train_on_batch(xfake, yfake)
    _, acc_fake = d.evaluate(xfake, yfake, verbose=0)
    print('>Accuracy real: %.0f%%, fake: %.0f%%' % (acc_real*100, acc_fake*100))
    pyplot.imshow(xfake[1, :, :, 0])
    pyplot.show()
    # filename = 'generator_model_%03d.h5' % (epoch + 1)
    # g.save(filename)

def train(gen, disc, data, epochs=4, n_batch=32) :
    bat_per_epo = int(397/n_batch)
    for i in range(epochs):
        for j in range(bat_per_epo):
            xreal, yreal = CGAN.gen_real(data, int(n_batch/2))
            # _, D_real = model.train_on_batch(xreal, yreal)
            xfake, yfake = CGAN.gen_synthetic(CGAN, G, int(n_batch/2))
            # _, D_noise = model.train_on_batch(xfake, yfake)
            x, y = np.vstack((xreal,xfake)), np.vstack((yreal,yfake))
            disc_loss, _ = D.train_on_batch(x, y)
            noise = CGAN.gen_gauss(100, n_batch)
            labels = np.ones((n_batch, 1))
            g_loss = GAN.train_on_batch(noise, labels)
            print('>%d, %d/%d, d=%.3f, g=%.3f' % (i+1, j+1, bat_per_epo, disc_loss, g_loss))
            if (j == 2 or j == 4 or j == 6):
                evaluate(i, gen, disc, data)
# train_disc(D, train)

train(G, D, train)
